<!DOCTYPE html>
<html>
  <head>
    <title>Slides</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      img { max-width: 500px; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible
import org.http4s._, org.http4s.dsl.io._, org.http4s.implicits._, org.http4s.server._
import cats._
import cats.data._
import cats.implicits._
import cats.effect._
import scala.concurrent.ExecutionContext.Implicits.global

implicit val cs: ContextShift[IO] = IO.contextShift(global)
implicit val timer: Timer[IO] = IO.timer(global)
```

class: center, middle

<h1>http4s</h1>

Mark de Jong

---

# whoami?

<img src="http://vectos.net/img/logo.png" align="right" />

## Mark de Jong
- Freelance software consultant
- Functional programming enthusiast

---

# http4s: What is it ?

- It's a _minimal Scala library_ for serving HTTP 1.x and 2.x requests!
- Low dependency footprint and flexible setup
- Descriptive and immutable types
- Favors functional programming to gain composability and reasoning

---

class: center, middle

<h1>Minimal example</h1>

---

# http4s: Minimal example

```tut:silent
val helloWorldService = HttpRoutes.of[IO] {
  case GET -> Root / "hello" / name =>
    Ok(s"Hello, $name.")
}

val routes = helloWorldService.orNotFound

```
---

# http4s: Minimal example

```tut:silent
val resp1 = routes.run(Request(Method.GET, Uri.uri("/hello/world"))).unsafeRunSync()
```
```tut
resp1.status
resp1.headers
resp1.as[String].unsafeRunSync()
```

---

# http4s: Minimal example

```tut:silent
val resp2 = routes.run(Request(Method.GET, Uri.uri("/i-dont-exist"))).unsafeRunSync()
```

```tut
resp2.status
resp2.headers
```

---

class: center, middle

<h1>Let's build http4s!</h1>

Disclaimer, kind of.. :)

---

# What do you need to handle a HTTP request?

- A function which handles a request and returns a response
- Decode data from a request
- Encode data into a response

---

# http4s Request/response

```scala
case class Request[F[_]](
    method: Method = Method.GET,
    uri: Uri = Uri(path = "/"),
    httpVersion: HttpVersion = HttpVersion.`HTTP/1.1`,
    headers: Headers = Headers.empty,
    body: fs2.Stream[F, Byte] = EmptyBody,
    attributes: AttributeMap = AttributeMap.empty
)

case class Response[F[_]](
    status: Status = Status.Ok,
    httpVersion: HttpVersion = HttpVersion.`HTTP/1.1`,
    headers: Headers = Headers.empty,
    body: fs2.Stream[F, Byte] = EmptyBody,
    attributes: AttributeMap = AttributeMap.empty
)
```

---

# We need function..!

> A function which handles a request and returns a response

- The function needs to be combined to support multiple endpoints
- A function can fail due side-effects

---

# Attempt #1 - A pure total function

```scala
type Endpoint = Request[IO] => Response[IO]
```

- ❌ We _cannot_ fail due side-effects
- ❌ We _cannot_ combine multiple endpoints

---

# Attempt #2 - A pure total function

```scala
type Endpoint = Request[IO] => IO[Response[IO]]
```

- ✅ We can fail due side-effects
- ❌ We _cannot_ combine multiple endpoints

---


# Attempt #3 - A pure partial function

```scala
type Route = PartialFunction[Request[IO], IO[Response[IO]]]
```

- ✅ We can fail due side-effects
- ✅ We can combine multiple endpoints
- ❌ We _cannot_ write *polymorphic* middleware for routes

---

# Monomorphic middlware

```scala
type Route = PartialFunction[Request[IO], IO[Response[IO]]]
type Middleware = Route => Route
```

- ❌ Our effect type is monomorphic which kills support for Monix and ZIO
- ❌ PartialFunction has limited set of helper functions
- ❌ We cannot use natural transformations to transform our effect type
- ✅ Middleware composes through function composition

---

# Polymorphic middlware

```tut:silent
type Route[F[_]] = Kleisli[OptionT[F, *], Request[F], F[Response[F]]]
type Middleware[F[_]] = HttpRoutes[F] => HttpRoutes[F]
```

- ✅ Our effect type is polymorphic now
- ✅ OptionT and Kleisli have a rich set of instances and helper functions
- ✅ We can use natural transformations to transform our effect type
- ✅ Middleware composes through function composition

---

# OptionT

```scala
final case class OptionT[F[_], A](value: F[Option[A]])
```

OptionT is a light wrapper on an `F[Option[A]]` with some convenient methods for working with this nested structure.

```tut:silent
type Route = PartialFunction[Request[IO], IO[Response[IO]]]

val routeA: Route = { case req if req.method == GET => Ok("GET") }
val routeB: Route = { case req if req.method == POST => Ok("POST") }

def totalRoute(route: Route): Request[IO] => OptionT[IO, Response[IO]] =
  req => OptionT(route.lift(req).sequence)
```

---

# OptionT

- It has all kinds of combinators like `flatMap`, `traverse`, `orElse`
- All kinds of instances like `Monad` and most importantly **SemigroupK**

```scala
trait OptionTSemigroupK[F[_]] extends SemigroupK[OptionT[F, *]] {
  implicit def F: Monad[F]
  def combineK[A](x: OptionT[F, A], y: OptionT[F, A]): OptionT[F, A] =
    x.orElse(y)
}
```

---

# SemigroupK

SemigroupK allows two F[A] values to be combined, for any A. The combination operation just depends on the structure of F, but not the structure of A.

```scala
trait SemigroupK[F[_]] {
  def combineK[A](x: F[A], y: F[A]): F[A]
}
```

---

# Kleisli

```scala
final case class Kleisli[F[_], A, B](run: A => F[B])
```

Kleisli enables composition of functions that return a *monadic* value

```tut
Kleisli(totalRoute(routeA))
```

---

# Kleisli

- It has all kinds of combinators like `andThen`, `flatMap`, `traverse`, etc
- As well it has all kinds of instances like `Monad` and most importantly **SemigroupK**

```scala
trait KleisliSemigroupK[F[_], A] extends SemigroupK[Kleisli[F, A, *]] {
  implicit def F: SemigroupK[F]

  override def combineK[B](x: Kleisli[F, A, B], y: Kleisli[F, A, B]): Kleisli[F, A, B] =
    Kleisli(a => F.combineK(x.run(a), y.run(a)))
}
```

---

# Putting it together

### Lifting into Kleisli

```tut:silent
val handlerA = Kleisli(totalRoute(routeA))
val handlerB = Kleisli(totalRoute(routeB))
```

### Compose into one handler

```tut
val handler = (handlerA <+> handlerB).orNotFound
```
---

# Putting it together

### Run the requests

```tut:silent
val respA = handler.run(Request(Method.GET, Uri.uri("/"))).unsafeRunSync()
val respB = handler.run(Request(Method.POST, Uri.uri("/"))).unsafeRunSync()
```

### Et voila, evaluate the response

```tut
respA.as[String].unsafeRunSync()
```
```tut
respB.as[String].unsafeRunSync()
```


---

class: center, middle

<h1>Encode data into a response</h1>

---

# `EntityEncoder` type class

### Definition (simpified)

```scala
final case class Entity[+F[_]](body: fs2.Stream[F, Byte], length: Option[Long])
trait EntityEncoder[F[_], A] {
  def toEntity(a: A): Entity[F]
  def headers: Headers
}
```

### Noteable instance: `Contravariant`

```scala
implicit def entityEncoderContravariant[F[_]]: Contravariant[EntityEncoder[F, *]] =
  new Contravariant[EntityEncoder[F, *]] {
    def contramap[A, B](r: EntityEncoder[F, A])(f: (B) => A): EntityEncoder[F, B] =
      new EntityEncoder[F, B] {
        def toEntity(a: B): Entity[F] = r.toEntity(f(a))
        def headers: Headers = r.headers
      }
  }
```

---

# Twirl `EntityEncoder`

```scala
implicit def xmlContentEncoder[F[_]](implicit charset: Charset): EntityEncoder[F, Xml] =
  contentEncoder(MediaType.application.xml)

def contentEncoder[F[_], C <: Content](mediaType: MediaType)
                                      (implicit charset: Charset): EntityEncoder[F, C] =
  EntityEncoder
    .stringEncoder[F]
    .contramap[C](_.body)
    .withContentType(`Content-Type`(mediaType, charset))
```

---

class: center, middle

<h1>Decode data from a request</h1>

---


# `EntityDecoder` type class

### Definition (simpified)

```scala
trait EntityDecoder[F[_], T] { self =>
  def decode(msg: Request[F], strict: Boolean): EitherT[F, DecodeFailure, T]
  def consumes: Set[MediaRange]
}
```

Noteable instance: `SemigroupK`

---

# UrlForm `EntityDecoder`

### Definition (simpified)

```scala
case class UrlForm (values: Map[String, List[String]])

def decodeString(charset: Charset)(urlForm: String): Either[MalformedMessageBodyFailure, UrlForm] =
  ??? //omitted urlencoded parsing

implicit def entityDecoder[F[_] : Monad](defaultCharset: Charset): EntityDecoder[F, UrlForm] =
  EntityDecoder.decodeBy(MediaType.application.`x-www-form-urlencoded`) { m =>
    EitherT(
      EntityDecoder
        .decodeString(m) // folds the `fs.stream[F, Byte]` into a F[String]
        .map(decodeString(m.charset.getOrElse(defaultCharset)))
    )
  }
```

---

# Fin

### Slides
[http://fristi.github.com/http4s-deck](http://fristi.github.com/http4s-deck)

### Libraries mentioned
- http4s at [https://http4s.org/](https://http4s.org/)
- cats at [https://typelevel.org/cats/](https://typelevel.org/cats/)
- cats-effect at [https://typelevel.org/cats-effect/](https://typelevel.org/cats-effect/)
- fs2 at [http://fs2.io/](http://fs2.io/)

 </textarea>
    <script src="remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
