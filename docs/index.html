<!DOCTYPE html>
<html>
  <head>
    <title>Slides</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      img { max-width: 500px; }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

<h1>http4s</h1>

Mark de Jong

---

# whoami?

<img src="http://vectos.net/img/logo.png" align="right" />

## Mark de Jong
- Freelance software consultant
- Functional programming enthusiast
- Open source contributor

### Find me at
- Twitter [https://twitter.com/mark_dj](https://twitter.com/mark_dj)
- Github [https://github.com/Fristi](https://github.com/fristi)

---

# Agenda

- What is it?
- Minimal example
- Frontends and backends
- Extensiblity through type classes
- Deep dive into the internals
  - Routing
  - Middleware
  - Streaming

---

# http4s: What is it ?

- It's a _minimal library_ for serving HTTP 1.x and 2.x requests!
- Low dependency footprint and flexible setup
- Descriptive and immutable types
- Favors functional programming to gain composability and reasoning
- Testing is easy (no tests kits needed!)

---

# cats

> lightweight, modular, and extensible library for functional programming

TODO

---

# cats-effect

> a set of typeclasses which characterize general effect types

TODO

---

# fs2

> a streaming library for handling large payloads in constant space

TODO

---

class: center, middle

<h1>Minimal example</h1>

---

# http4s: Minimal example

This uses the http4s-dsl frontend/module (Scala extractors)

```scala
val helloWorldService = HttpRoutes.of[IO] {
  case GET -> Root / "hello" / name =>
    Ok(s"Hello, $name.")
}

val routes = helloWorldService.orNotFound

```
---

# http4s: Minimal example

```scala
val resp1 = routes.run(Request(Method.GET, Uri.uri("/hello/world"))).unsafeRunSync()
```
```scala
scala> resp1.status
res0: org.http4s.Status = 200 OK

scala> resp1.headers
res1: org.http4s.Headers = Headers(Content-Type: text/plain; charset=UTF-8, Content-Length: 13)

scala> resp1.as[String].unsafeRunSync()
res2: String = Hello, world.
```

```scala
val resp2 = routes.run(Request(Method.GET, Uri.uri("/i-dont-exist"))).unsafeRunSync()
```
```scala
scala> resp2.status
res3: org.http4s.Status = 404 Not Found

scala> resp2.headers
res4: org.http4s.Headers = Headers(Content-Type: text/plain; charset=UTF-8)
```

---

# http4s Request/response

```scala
case class Request[F[_]](
    method: Method = Method.GET,
    uri: Uri = Uri(path = "/"),
    httpVersion: HttpVersion = HttpVersion.`HTTP/1.1`,
    headers: Headers = Headers.empty,
    body: fs2.Stream[F, Byte] = EmptyBody,
    attributes: AttributeMap = AttributeMap.empty
)

case class Response[F[_]](
    status: Status = Status.Ok,
    httpVersion: HttpVersion = HttpVersion.`HTTP/1.1`,
    headers: Headers = Headers.empty,
    body: fs2.Stream[F, Byte] = EmptyBody,
    attributes: AttributeMap = AttributeMap.empty)

```

---

# http4s: Run it as a server

```scala
object Main extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    BlazeServerBuilder[IO]
      .bindHttp(8080, "localhost")
      .withHttpApp(routes)
      .serve
      .compile
      .drain
      .as(ExitCode.Success)
}
```

---

class: center, middle

<h1>Middleware</h1>

---

# http4s Middleware

Included middleware

- Authentication
- Cross Origin Resource Sharing (CORS)
- Response Compression (GZip)
- Service Timeout
- Jsonp
- Virtual Host
- Metrics

---

class: center, middle

<h1>Extensiblity</h1>

---

# http4s Extensiblity through type classes

### Two essential type classes

- `EntityEncoder` for encoding responses like HTML, JSON, XML, etc
- `EntityDecoder` for decoding requests like form-encoded, JSON, XML, etc

### Common practice in functional programming

- Define a type class
- Create instances of other type classes like `Contravariant`, `SemigroupK`, `Monoid`, etc

---

class: center, middle

<h1>EntityEncoder</h1>

---

# `EntityEncoder` type class

### Definition (simpified)

```scala
final case class Entity[+F[_]](body: fs2.Stream[F, Byte], length: Option[Long])
trait EntityEncoder[F[_], A] {
  def toEntity(a: A): Entity[F]
  def headers: Headers
}
```

### Noteable instance: `Contravariant`

```scala
implicit def entityEncoderContravariant[F[_]]: Contravariant[EntityEncoder[F, ?]] =
  new Contravariant[EntityEncoder[F, ?]] {
    def contramap[A, B](r: EntityEncoder[F, A])(f: (B) => A): EntityEncoder[F, B] =
      new EntityEncoder[F, B] {
        def toEntity(a: B): Entity[F] = r.toEntity(f(a))
        def headers: Headers = r.headers
      }
  }
```

---

# Twirl `EntityEncoder`

```scala
implicit def xmlContentEncoder[F[_]](implicit charset: Charset): EntityEncoder[F, Xml] =
  contentEncoder(MediaType.application.xml)

def contentEncoder[F[_], C <: Content](mediaType: MediaType)
                                      (implicit charset: Charset): EntityEncoder[F, C] =
  EntityEncoder
    .stringEncoder[F]
    .contramap[C](_.body)
    .withContentType(`Content-Type`(mediaType, charset))
```

---

class: center, middle

<h1>EntityDecoder</h1>

---


# `EntityDecoder` type class

### Definition (simpified)

```scala
trait EntityDecoder[F[_], T] { self =>
  def decode(msg: Request[F], strict: Boolean): EitherT[F, DecodeFailure, T]
  def consumes: Set[MediaRange]
}
```

Noteable instance: `SemigroupK`

---

# UrlForm `EntityDecoder`

### Definition (simpified)

```scala
case class UrlForm (values: Map[String, List[String]])

def decodeString(charset: Charset)(urlForm: String): Either[MalformedMessageBodyFailure, UrlForm] =
  ??? //omitted urlencoded parsing

implicit def entityDecoder[F[_] : Monad](defaultCharset: Charset): EntityDecoder[F, UrlForm] =
  EntityDecoder.decodeBy(MediaType.application.`x-www-form-urlencoded`) { m =>
    EitherT(
      EntityDecoder
        .decodeString(m) // folds the `fs.stream[F, Byte]` into a F[String]
        .map(decodeString(m.charset.getOrElse(defaultCharset)))
    )
  }
```

---



# http4s Extensible through type classes

Many Modules already provided

- Twirl
- Circe
- Argonaut
- Json4s
- Play-json
- Scalatags
- Scala-xml

---

class: center, middle

<h1>Frontends and backends</h1>

---

class: center, middle

<h1>Frontends?</h1>

---

# http4s Frontends

Frontends are built upon the core foundation of http4s. It will only use the core types (`HttpRoutes`, `Request[F]`, `Response[F]`)

Examples

- http4s-dsl (Extractors which allow simple endpoints)
- rho (A self documenting DSL built on http4s)

---

# http4s Frontends - examples

### rho

```scala
val httpService = new RhoService[IO] {
   GET / "hello" / 'world +? param[Int]("fav") |>> { (world: String, fav: Int) =>
     Ok(s"Received $fav, $world")
   }
}
```
---

class: center, middle

<h1>Backends?</h1>

---

# http4s Backends

- TODO: Netty
- TODO: Blaze
- TODO: Tech empower up

---

class: center, middle

<h1>Deep dive!</h1>

Internals of http4s

---

# http4s: A tale of types

### HttpRoutes type (simplified)

```scala
type HttpRoutes[F[_]] = Kleisli[OptionT[F, ?], Request[F], Response[F]]
```

- `F[_]` is the effect type (`cats.effect.IO`, monix `Task` or scalaz-zio)
- `Request[F]` is a HTTP request with a request body `fs2.Stream[F, Byte]`
- `Response[F]` is a HTTP response with a response body `fs2.Stream[F, Byte]`

### HttpRoutes companion object

```scala
def of[F[_]](pf: PartialFunction[Request[F], F[Response[F]]])(
      implicit F: Sync[F]): HttpRoutes[F]
```

`of` needs to translate `PartialFunction[Request[F], F[Response[F]]]` to `HttpRoutes`. So how?

- TODO: why do we need this translation?
- TODO: refresher of a `PartialFunction`

---

# Kleisli

> Kleisli enables composition of functions that return a monadic value

```scala
final case class Kleisli[F[_], A, B](run: A => F[B])
```

It has all kinds of combinators like
- `andThen`
- `flatMap`
- `traverse`

As well it has all kinds of instances like `Monad` and most importantly **SemigroupK**

#### Why?
*To work with effectful functions*

---

# OptionT

> `OptionT[F[_], A]` is a light wrapper on an `F[Option[A]]` with some convenient methods for working with this nested structure.

```scala
final case class OptionT[F[_], A](value: F[Option[A]])
```

It has all kinds of combinators like
- `flatMap`
- `traverse`
- `orElse`

As well it has all kinds of instances like `Monad` and most importantly **SemigroupK**

#### Why?
*To model the fact that the Kleisli arrow is not total*

---

# SemigroupK

> SemigroupK[F] allows two F[A] values to be combined, for any A. The combination operation just depends on the structure of F, but not the structure of A.

```scala
@typeclass trait SemigroupK[F[_]] { self =>
  @simulacrum.op("<+>", alias = true)
  def combineK[A](x: F[A], y: F[A]): F[A]
}
```

Why do we need this? *To combine values of F[A]*


---

# SemigroupK for our Kleisli

Remember our `HttpRoutes` ?

```scala
type HttpRoutes[F[_]] = Kleisli[OptionT[F, ?], Request[F], Response[F]]
```

Our `HttpRoutes` has a `SemigroupK` because `F` in `Kleisi[F, A, B]` has a `SemigroupK` instance:

```scala
scala> implicitly[SemigroupK[OptionT[IO, ?]]]
res5: cats.SemigroupK[[β$0$]cats.data.OptionT[cats.effect.IO,β$0$]] = cats.data.OptionTInstances0$$anon$8@60ae7475
```

We also have a `SemigroupK` instance for `Kleisli[OptionT[F, ?], Request[F], Response[F]]`
---

# SemigroupK for our Kleisli/OptionT

### [OptionT](https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/data/OptionT.scala#L443)

```scala
trait OptionTSemigroupK[F[_]] extends SemigroupK[OptionT[F, ?]] {
  implicit def F: Monad[F]

  def combineK[A](x: OptionT[F, A], y: OptionT[F, A]): OptionT[F, A] = x.orElse(y)
}
```

### [Kleisli](https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/data/Kleisli.scala#L410)

```scala
trait KleisliSemigroupK[F[_], A] extends SemigroupK[Kleisli[F, A, ?]] {
  implicit def F: SemigroupK[F]

  override def combineK[B](x: Kleisli[F, A, B], y: Kleisli[F, A, B]): Kleisli[F, A, B] =
    Kleisli(a => F.combineK(x.run(a), y.run(a)))
}
```

---

### Example of everything together

- TODO: Show it

---


class: center, middle

![Boom](https://media.giphy.com/media/26ufdipQqU2lhNA4g/giphy.gif)

---

# Kleisli middleware

```scala
type Middleware[F[_], A, B, C, D] = Kleisli[F, A, B] => Kleisli[F, C, D]
type HttpMiddleware[F[_]] =
    Middleware[OptionT[F, ?], Request[F], Response[F], Request[F], Response[F]]
```

```scala
val printlnRequest: HttpMiddleware[IO] = outer => Kleisli { req =>
  OptionT.liftF(IO.delay(println(s"Tracing request ${req.method} ${req.uri}"))) *>
    outer.run(req)
}

val router = printlnRequest(helloWorldService <+> statusService).orNotFound

```

```scala
scala> router.run(Request(Method.GET, Uri.uri("/hello/world"))).unsafeRunSync()
<console>:40: error: not found: value router
       router.run(Request(Method.GET, Uri.uri("/hello/world"))).unsafeRunSync()
       ^
```

Hint: middleware does compose through function composition :-)

---

# Fin

### Slides
[http://fristi.github.com/http4s-deck](http://fristi.github.com/http4s-deck)

### Libraries mentioned
- http4s at [https://http4s.org/](https://http4s.org/)
- cats at [https://typelevel.org/cats/](https://typelevel.org/cats/)
- cats-effect at [https://typelevel.org/cats-effect/](https://typelevel.org/cats-effect/)
- fs2 at [http://fs2.io/](http://fs2.io/)

 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
